namespace CaeriusNet.Generator.Dto;

public sealed partial class DtoSourceGenerator
{
	private static void Generate(SourceProductionContext context, ImmutableArray<DtoRecord> dtoRecords, bool isEnabled)
	{
		if (!isEnabled)
			return;

		if (dtoRecords.IsEmpty)
			return;

		foreach (var record in dtoRecords)
		{
			var writer = new SourceWriter()
				.AppendLine("// <auto-generated/>")
				.AppendLine("#nullable enable")
				.AppendLine()
				.AppendLine("using System;")
				.AppendLine("using System.Data;")
				.AppendLine("using Microsoft.Data.SqlClient;")
				.AppendLine("using System.Globalization;")
				.AppendLine("using CaeriusNet.Mappers;")
				.AppendLine()
				.AppendLine($"namespace {record.Namespace};")
				.AppendLine();

			// We're creating a partial record that implements ISpMapper
			writer.AppendLine($"public sealed partial record {record.RecordTypeName} : ISpMapper<{record.RecordTypeName}>");

			using (writer.CreateScope())
			{
				// Implement the static MapFromDataReader method required by ISpMapper
				writer.AppendIndentedLine(
						$"public static {record.RecordTypeName} MapFromDataReader(SqlDataReader reader)")
					.AppendIndentedLine("{");

				writer.Indent();

				// Check for null reader
				writer.AppendIndentedLine("if (reader == null)")
					.AppendIndentedLine("    throw new ArgumentNullException(nameof(reader));")
					.AppendLine();

				// Create new instance based on constructor parameters
				if (record.Properties.Count > 0)
				{
					writer.AppendIndentedLine($"return new {record.RecordTypeName}(");

					writer.Indent();

					for (var i = 0; i < record.Properties.Count; i++)
					{
						var property = record.Properties[i];
						var isLast = i == record.Properties.Count - 1;

						GeneratePropertyMapping(writer, property, i);
						writer.Append(isLast ? "" : ",").AppendLine();
					}

					writer.Unindent().AppendIndentedLine(");");
				}
				else
				{
					writer.AppendIndentedLine($"return new {record.RecordTypeName}();");
				}

				writer.Unindent().AppendIndentedLine("}");
			}

			context.AddSource($"{record.RecordTypeName}.g.cs", writer.ToSourceText());
		}
	}

	private static void GeneratePropertyMapping(SourceWriter writer, DtoProperty property, int index)
	{
		writer.AppendIndented("");

		var typeName = property.TypeName;

		// Gestion des valeurs nullables
		if (property.IsNullable)
		{
			// Ajouter la vérification IsDBNull pour tous les types nullables
			writer.Append($"reader.IsDBNull({index}) ? ");

			// Différencier entre les types référence (null) et les types valeur (default)
			if (typeName.StartsWith("System.Nullable<") ||
			    typeName == "string" || typeName == "object" ||
			    typeName == "byte[]" || typeName == "System.Byte[]")
				writer.Append("null : ");
			else
				writer.Append("default : ");
		}

		// Générer la conversion appropriée pour le type
		GenerateTypeSpecificReaderCall(writer, property, index);
	}

	private static void GenerateTypeSpecificReaderCall(SourceWriter writer, DtoProperty property, int index)
	{
		var typeName = property.TypeName;

		// Extraire le nom du type de base pour les types Nullable<T>
		var baseTypeName = typeName;
		if (typeName.StartsWith("System.Nullable<"))
			// Extraire T de Nullable<T>
			baseTypeName = typeName.Substring(16, typeName.Length - 17);

		// Traiter les types spéciaux d'abord
		switch (baseTypeName)
		{
			case "System.Boolean":
			case "bool":
				writer.Append($"reader.GetBoolean({index})");
				return;

			case "System.Byte":
			case "byte":
				writer.Append($"reader.GetByte({index})");
				return;

			case "System.Int16":
			case "short":
				writer.Append($"reader.GetInt16({index})");
				return;

			case "System.Int32":
			case "int":
				writer.Append($"reader.GetInt32({index})");
				return;

			case "System.Int64":
			case "long":
				writer.Append($"reader.GetInt64({index})");
				return;

			case "System.Single":
			case "float":
				writer.Append($"reader.GetFloat({index})");
				return;

			case "System.Double":
			case "double":
				writer.Append($"reader.GetDouble({index})");
				return;

			case "System.Decimal":
			case "decimal":
				writer.Append($"reader.GetDecimal({index})");
				return;

			case "System.String":
			case "string":
				writer.Append($"reader.GetString({index})");
				return;

			case "System.Char":
			case "char":
				writer.Append($"reader.GetString({index})[0]");
				return;

			case "System.DateTime":
			case "DateTime":
				writer.Append($"reader.GetDateTime({index})");
				return;

			case "System.Guid":
			case "Guid":
				writer.Append($"reader.GetGuid({index})");
				return;

			case "System.DateTimeOffset":
			case "DateTimeOffset":
				writer.Append($"reader.GetDateTimeOffset({index})");
				return;

			case "System.TimeSpan":
			case "TimeSpan":
				writer.Append($"reader.GetTimeSpan({index})");
				return;
		}

		switch (baseTypeName)
		{
			// Types qui nécessitent une conversion spéciale
			case "System.DateOnly" or "DateOnly":
				writer.Append($"DateOnly.FromDateTime(reader.GetDateTime({index}))");
				break;
			case "System.TimeOnly" or "TimeOnly":
				writer.Append($"TimeOnly.FromDateTime(reader.GetDateTime({index}))");
				break;
			case "byte[]" or "System.Byte[]":
				writer.Append($"(byte[])reader.GetValue({index})");
				break;
			case "object" or "System.Object":
				writer.Append($"reader.GetValue({index})");
				break;
			// Fallback pour tout autre type non géré
			default:
				writer.Append($"({baseTypeName})reader.GetValue({index})");
				break;
		}
	}
}