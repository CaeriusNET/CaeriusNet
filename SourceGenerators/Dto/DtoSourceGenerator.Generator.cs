namespace CaeriusNet.Generator.Dto;

public sealed partial class DtoSourceGenerator
{
	/// <summary>
	///     Generates the complete source code for an <see cref="ISpMapper{T}" /> implementation.
	/// </summary>
	/// <param name="metadata">The metadata containing all necessary information for code generation.</param>
	/// <returns>A string containing the complete C# source code for the DTO mapper.</returns>
	/// <remarks>
	///     <para>
	///         The generated code includes:
	///     </para>
	///     <list type="bullet">
	///         <item>
	///             <description>Auto-generated file header with nullable enable directive</description>
	///         </item>
	///         <item>
	///             <description>Required using statements (System, SqlClient, CaeriusNet.Mappers)</description>
	///         </item>
	///         <item>
	///             <description>File-scoped namespace declaration</description>
	///         </item>
	///         <item>
	///             <description>Partial type implementing ISpMapper interface</description>
	///         </item>
	///         <item>
	///             <description>MapFromDataReader static method that efficiently reads from SqlDataReader by ordinal position</description>
	///         </item>
	///     </list>
	///     <para>
	///         The generated mapper handles nullability, type conversions, enums, and special types like DateOnly/TimeOnly.
	///     </para>
	/// </remarks>
	private static string GenerateMapperSource(Metadata metadata)
	{
		// Estimate capacity: ~400 base + ~80 per parameter
		int estimatedCapacity = 400 + metadata.Parameters.Count * 80;
		var source = new StringBuilder(estimatedCapacity);

		// File header
		source.AppendLine("// <auto-generated by CaeriusNet.Generator />");
		source.AppendLine("#nullable enable");
		source.AppendLine();

		// Using directives
		source.AppendLine("using System;");
		source.AppendLine("using Microsoft.Data.SqlClient;");
		source.AppendLine("using CaeriusNet.Mappers;");
		source.AppendLine();

		// File-scoped namespace
		source.AppendLine($"namespace {metadata.Namespace};");
		source.AppendLine();

		// Type declaration
		string declarationType = metadata.DeclarationSyntax.Kind() == SyntaxKind.ClassDeclaration ? "class" : "record";
		source.AppendLine($"public sealed partial {declarationType} {metadata.RecordName} : ISpMapper<{metadata.RecordName}>");
		source.AppendLine("{");

		// MapFromDataReader method signature
		source.AppendLine($"    public static {metadata.RecordName} MapFromDataReader(SqlDataReader reader)");
		source.AppendLine("    {");

		// Constructor call with reader expressions
		source.AppendLine($"        return new {metadata.RecordName}(");

		// Generate parameter reader expressions
		for (int i = 0; i < metadata.Parameters.Count; i++){
			var parameter = metadata.Parameters[i];
			string comma = i < metadata.Parameters.Count - 1 ? "," : "";
			source.AppendLine($"            {GetReaderExpression(parameter)}{comma}");
		}

		source.AppendLine("        );");
		source.AppendLine("    }");
		source.AppendLine("}");

		return source.ToString();
	}

	/// <summary>
	///     Generates the appropriate SqlDataReader expression for reading a parameter value.
	/// </summary>
	/// <param name="parameter">The parameter metadata containing type and nullability information.</param>
	/// <returns>
	///     A C# expression string that reads the parameter value from SqlDataReader by ordinal position,
	///     with appropriate null handling, type conversions, and enum casts.
	/// </returns>
	/// <remarks>
	///     <para>
	///         This method generates optimized reader expressions that:
	///     </para>
	///     <list type="bullet">
	///         <item>
	///             <description>Use ordinal-based column access for maximum performance</description>
	///         </item>
	///         <item>
	///             <description>Handle nullable and non-nullable types correctly</description>
	///         </item>
	///         <item>
	///             <description>Apply special conversions for DateOnly, TimeOnly, byte[], and char types</description>
	///         </item>
	///         <item>
	///             <description>Cast enum values from their underlying types</description>
	///         </item>
	///         <item>
	///             <description>Check for DBNull only when the parameter is nullable</description>
	///         </item>
	///     </list>
	/// </remarks>
	private static string GetReaderExpression(ParameterMetadata parameter)
	{
		int ordinal = parameter.OrdinalPosition;
		bool isEnum = parameter.TypeSymbol.TypeKind == TypeKind.Enum;
		string enumCast = isEnum ? $"({parameter.TypeName})" : "";

		// Non-nullable types: Direct reader access without null checks
		if (!parameter.IsNullable)
			return parameter.TypeName switch
			{
				var tn when tn.Contains("byte[]") =>
					$"(byte[])reader.GetValue({ordinal})",

				var tn when tn.Contains("DateOnly") =>
					$"DateOnly.FromDateTime(reader.GetDateTime({ordinal}))",

				var tn when tn.Contains("TimeOnly") =>
					$"TimeOnly.FromDateTime(reader.GetDateTime({ordinal}))",

				var tn when tn.Contains("char") =>
					$"reader.GetString({ordinal})[0]",

				_ => isEnum
					? $"{enumCast}reader.{parameter.ReaderMethod}({ordinal})"
					: $"reader.{parameter.ReaderMethod}({ordinal})"
			};

		// Nullable types: Include DBNull check with ternary operator
		string nullCheck = $"reader.IsDBNull({ordinal}) ? null : ";

		return parameter.TypeName switch
		{
			var tn when tn.Contains("byte[]") =>
				$"{nullCheck}(byte[])reader.GetValue({ordinal})",

			var tn when tn.Contains("DateOnly") =>
				$"{nullCheck}DateOnly.FromDateTime(reader.GetDateTime({ordinal}))",

			var tn when tn.Contains("TimeOnly") =>
				$"{nullCheck}TimeOnly.FromDateTime(reader.GetDateTime({ordinal}))",

			var tn when tn.Contains("char") =>
				$"{nullCheck}reader.GetString({ordinal})[0]",

			_ => isEnum
				? $"{nullCheck}{enumCast}reader.{parameter.ReaderMethod}({ordinal})"
				: $"{nullCheck}reader.{parameter.ReaderMethod}({ordinal})"
		};
	}
}