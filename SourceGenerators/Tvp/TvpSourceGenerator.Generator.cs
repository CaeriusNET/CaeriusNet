using CaeriusNet.Generator.Models;
using Microsoft.CodeAnalysis;
using System;
using System.Linq;
using System.Text;
using Metadata=CaeriusNet.Generator.Models.Metadata;

namespace CaeriusNet.Generator.Tvp;

public sealed partial class TvpSourceGenerator
{
	/// <summary>
	///     Generates the ITvpMapper implementation for the specified metadata.
	/// </summary>
	/// <param name="context">The source production context.</param>
	/// <param name="metadata">The TVP metadata.</param>
	private static void GenerateTvpMapper(SourceProductionContext context, Metadata metadata)
	{
		string sourceCode = GenerateTvpMapperSource(metadata);
		string fileName = $"{metadata.RecordName}.g.cs";

		context.AddSource(fileName, sourceCode);
	}

	/// <summary>
	///     Generates the complete source code for the ITvpMapper implementation.
	/// </summary>
	/// <param name="metadata">The TVP metadata.</param>
	/// <returns>The generated source code.</returns>
	private static string GenerateTvpMapperSource(Metadata metadata)
	{
		var sb = new StringBuilder();

		// File header and usings
		AppendFileHeader(sb);
		AppendUsings(sb);

		// Namespace and class declaration
		AppendNamespaceStart(sb, metadata.Namespace);
		AppendClassDeclaration(sb, metadata);

		// Generate the MapAsDataTable method
		AppendMapAsDataTableMethod(sb, metadata);

		// Close class and namespace
		AppendClassEnd(sb);
		AppendNamespaceEnd(sb, metadata.Namespace);

		return sb.ToString();
	}

	/// <summary>
	///     Appends the file header with auto-generated comment.
	/// </summary>
	private static void AppendFileHeader(StringBuilder sb)
	{
		sb.AppendLine("// <auto-generated/>");
		sb.AppendLine("#nullable enable");
		sb.AppendLine();
	}

	/// <summary>
	///     Appends the necessary using statements.
	/// </summary>
	private static void AppendUsings(StringBuilder sb)
	{
		sb.AppendLine("using System;");
		sb.AppendLine("using System.Collections.Generic;");
		sb.AppendLine("using System.Data;");
		sb.AppendLine("using CaeriusNet.Mappers;");
		sb.AppendLine();
	}

	/// <summary>
	///     Appends the namespace start.
	/// </summary>
	private static void AppendNamespaceStart(StringBuilder sb, string namespaceName)
	{
		if (string.IsNullOrEmpty(namespaceName))
			return;

		sb.AppendLine($"namespace {namespaceName};");
		sb.AppendLine();
	}

	/// <summary>
	///     Appends the class declaration with ITvpMapper implementation.
	/// </summary>
	private static void AppendClassDeclaration(StringBuilder sb, Metadata metadata)
	{
		sb.AppendLine($"public sealed partial record {metadata.RecordName} : ITvpMapper<{metadata.RecordName}>");
		sb.AppendLine("{");
	}

	/// <summary>
	///     Appends the MapAsDataTable method implementation.
	/// </summary>
	private static void AppendMapAsDataTableMethod(StringBuilder sb, Metadata metadata)
	{
		string tvpName = GetTvpName(metadata);

		sb.AppendLine("    /// <summary>");
		sb.AppendLine($"    ///     Maps a collection of {metadata.RecordName} objects to a DataTable for TVP usage.");
		sb.AppendLine("    /// </summary>");
		sb.AppendLine($"    public DataTable MapAsDataTable(IEnumerable<{metadata.RecordName}> items)");
		sb.AppendLine("    {");
		sb.AppendLine($"        var dataTable = new DataTable(\"{tvpName}\");");
		sb.AppendLine();

		// Add columns
		AppendColumnDefinitions(sb, metadata);
		sb.AppendLine();

		// Add rows
		AppendRowPopulation(sb, metadata);

		sb.AppendLine();
		sb.AppendLine("        return dataTable;");
		sb.AppendLine("    }");
	}

	/// <summary>
	///     Gets the fully qualified TVP name in the format [Schema].[TvpName].
	/// </summary>
	private static string GetTvpName(Metadata metadata)
	{
		string schema = metadata.TvpSchema ?? "dbo";
		string tvpName = metadata.TvpName ?? throw new InvalidOperationException("TvpName is required");

		return $"{schema}.{tvpName}";
	}

	/// <summary>
	///     Appends the column definitions for the DataTable.
	/// </summary>
	private static void AppendColumnDefinitions(StringBuilder sb, Metadata metadata)
	{
		sb.AppendLine("        // Add columns");
		foreach (var parameter in metadata.Parameters){
			string dotNetType = GetDotNetTypeForDataTable(parameter);
			sb.AppendLine($"        dataTable.Columns.Add(\"{parameter.Name}\", typeof({dotNetType}));");
		}
	}

	/// <summary>
	///     Appends the row population logic.
	/// </summary>
	private static void AppendRowPopulation(StringBuilder sb, Metadata metadata)
	{
		sb.AppendLine("        // Populate rows");
		sb.AppendLine("        foreach (var item in items)");
		sb.AppendLine("        {");

		var parameterValues = metadata.Parameters
			.Select(p => $"item.{p.Name}")
			.ToList();

		string valuesString = string.Join(", ", parameterValues);
		sb.AppendLine($"            dataTable.Rows.Add({valuesString});");

		sb.AppendLine("        }");
	}

	/// <summary>
	///     Gets the appropriate .NET type for DataTable column definition.
	/// </summary>
	private static string GetDotNetTypeForDataTable(ParameterMetadata parameter)
	{
		// For DataTable columns, we need the underlying type (not nullable)
		string typeName = parameter.TypeName;

		// Remove nullable annotation if present
		if (typeName.EndsWith("?")) typeName = typeName.TrimEnd('?');

		// Handle Nullable<T> syntax
		if (typeName.StartsWith("System.Nullable<") && typeName.EndsWith(">"))
			typeName = typeName.Substring(16, typeName.Length - 17);

		// Map common type aliases to their full names
		return typeName switch
		{
			"int" => "int",
			"long" => "long",
			"short" => "short",
			"byte" => "byte",
			"bool" => "bool",
			"decimal" => "decimal",
			"double" => "double",
			"float" => "float",
			"string" => "string",
			"DateTime" => "DateTime",
			"DateTimeOffset" => "DateTimeOffset",
			"TimeSpan" => "TimeSpan",
			"Guid" => "Guid",
			"DateOnly" => "DateOnly",
			"TimeOnly" => "TimeOnly",
			"byte[]" => "byte[]",
			_ => typeName
		};
	}

	/// <summary>
	///     Appends the class closing brace.
	/// </summary>
	private static void AppendClassEnd(StringBuilder sb)
	{
		sb.AppendLine("}");
	}

	/// <summary>
	///     Appends the namespace end if needed.
	/// </summary>
	private static void AppendNamespaceEnd(StringBuilder sb, string namespaceName)
	{
		// With file-scoped namespaces, we don't need to close them
	}
}