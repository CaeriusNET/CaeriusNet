namespace CaeriusNet.Generator.Tvp;

public sealed partial class TvpSourceGenerator
{
	/// <summary>
	///     Generates and adds the <see cref="ITvpMapper{T}" /> implementation source code to the compilation.
	/// </summary>
	/// <param name="context">The source production context for adding generated source files.</param>
	/// <param name="metadata">The metadata containing type and TVP configuration information.</param>
	/// <remarks>
	///     This method orchestrates the complete code generation process for a single TVP mapper,
	///     producing a file named "{TypeName}.g.cs" containing the implementation.
	/// </remarks>
	private static void GenerateTvpMapper(SourceProductionContext context, Metadata metadata)
    {
        var sourceCode = GenerateTvpMapperSource(metadata);
        var fileName = $"{metadata.RecordName}.g.cs";

        context.AddSource(fileName, sourceCode);
    }

	/// <summary>
	///     Generates the complete source code for an <see cref="ITvpMapper{T}" /> implementation.
	/// </summary>
	/// <param name="metadata">The metadata containing all necessary information for code generation.</param>
	/// <returns>A string containing the complete C# source code for the TVP mapper.</returns>
	/// <remarks>
	///     <para>
	///         The generated code includes:
	///     </para>
	///     <list type="bullet">
	///         <item>
	///             <description>Auto-generated file header with nullable enable directive</description>
	///         </item>
	///         <item>
	///             <description>Required using statements</description>
	///         </item>
	///         <item>
	///             <description>File-scoped namespace declaration</description>
	///         </item>
	///         <item>
	///             <description>Partial class/record implementing ITvpMapper</description>
	///         </item>
	///         <item>
	///             <description>MapAsDataTable method that creates and populates a DataTable</description>
	///         </item>
	///     </list>
	/// </remarks>
	private static string GenerateTvpMapperSource(Metadata metadata)
    {
        // Estimate capacity: ~500 base + ~100 per parameter
        var estimatedCapacity = 500 + metadata.Parameters.Count * 100;
        var sb = new StringBuilder(estimatedCapacity);

        // File header and usings
        AppendFileHeader(sb);
        AppendUsings(sb);

        // Namespace and class declaration
        AppendNamespaceStart(sb, metadata.Namespace);
        AppendClassDeclaration(sb, metadata);

        // Generate the MapAsDataTable method
        AppendMapAsDataTableMethod(sb, metadata);

        // Close class and namespace
        AppendClassEnd(sb);
        AppendNamespaceEnd(sb, metadata.Namespace);

        return sb.ToString();
    }

	/// <summary>
	///     Appends the standard auto-generated file header.
	/// </summary>
	/// <param name="sb">The <see cref="StringBuilder" /> to append to.</param>
	/// <remarks>
	///     Includes an auto-generated comment and enables nullable reference types for the file.
	/// </remarks>
	private static void AppendFileHeader(StringBuilder sb)
    {
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();
    }

	/// <summary>
	///     Appends the required using directives for the generated TVP mapper.
	/// </summary>
	/// <param name="sb">The <see cref="StringBuilder" /> to append to.</param>
	/// <remarks>
	///     Includes namespaces for:
	///     <list type="bullet">
	///         <item>
	///             <description><see cref="System" /> - Core types</description>
	///         </item>
	///         <item>
	///             <description><see cref="System.Collections.Generic" /> - Generic collections</description>
	///         </item>
	///         <item>
	///             <description><see cref="System.Data" /> - DataTable and related ADO.NET types</description>
	///         </item>
	///         <item>
	///             <description>CaeriusNet.Mappers - ITvpMapper interface</description>
	///         </item>
	///     </list>
	/// </remarks>
	private static void AppendUsings(StringBuilder sb)
    {
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Collections.Generic;");
        sb.AppendLine("using System.Data;");
        sb.AppendLine("using CaeriusNet.Mappers;");
        sb.AppendLine();
    }

	/// <summary>
	///     Appends a file-scoped namespace declaration.
	/// </summary>
	/// <param name="sb">The <see cref="StringBuilder" /> to append to.</param>
	/// <param name="namespaceName">The namespace name, or empty/null for global namespace.</param>
	/// <remarks>
	///     Uses C# 10+ file-scoped namespace syntax. If the namespace is empty or null, no declaration is added.
	/// </remarks>
	private static void AppendNamespaceStart(StringBuilder sb, string namespaceName)
    {
        if (string.IsNullOrEmpty(namespaceName))
            return;

        sb.AppendLine($"namespace {namespaceName};");
        sb.AppendLine();
    }

	/// <summary>
	///     Appends the partial type declaration implementing <see cref="ITvpMapper{T}" />.
	/// </summary>
	/// <param name="sb">The <see cref="StringBuilder" /> to append to.</param>
	/// <param name="metadata">The metadata containing type information.</param>
	/// <remarks>
	///     Generates a sealed partial record with the ITvpMapper interface and includes
	///     a static TvpTypeName property containing the fully qualified TVP name ([Schema].[TvpName]).
	/// </remarks>
	private static void AppendClassDeclaration(StringBuilder sb, Metadata metadata)
    {
        sb.AppendLine($"public sealed partial record {metadata.RecordName} : ITvpMapper<{metadata.RecordName}>");
        sb.AppendLine("{");

        // Add static property for TVP type name
        var tvpName = GetTvpName(metadata);
        sb.AppendLine("    /// <summary>");
        sb.AppendLine("    ///     Gets the SQL Server type name for this TVP.");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine($"    public static string TvpTypeName => \"{tvpName}\";");
        sb.AppendLine();
    }

	/// <summary>
	///     Appends the MapAsDataTable method implementation.
	/// </summary>
	/// <param name="sb">The <see cref="StringBuilder" /> to append to.</param>
	/// <param name="metadata">The metadata containing parameter and TVP information.</param>
	/// <remarks>
	///     <para>
	///         Generates the MapAsDataTable method which converts a collection of objects into a properly structured
	///         <see cref="DataTable" /> for use as a SQL Server Table-Valued Parameter.
	///     </para>
	///     <para>
	///         The method:
	///     </para>
	///     <list type="number">
	///         <item>
	///             <description>Creates a new DataTable with the TVP name</description>
	///         </item>
	///         <item>
	///             <description>Defines columns matching the TVP schema</description>
	///         </item>
	///         <item>
	///             <description>Populates rows from the input collection</description>
	///         </item>
	///     </list>
	/// </remarks>
	private static void AppendMapAsDataTableMethod(StringBuilder sb, Metadata metadata)
    {
        var tvpName = GetTvpName(metadata);

        sb.AppendLine("    /// <summary>");
        sb.AppendLine($"    ///     Maps a collection of {metadata.RecordName} objects to a DataTable for TVP usage.");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine($"    public DataTable MapAsDataTable(IEnumerable<{metadata.RecordName}> items)");
        sb.AppendLine("    {");
        sb.AppendLine($"        var dataTable = new DataTable(\"{tvpName}\");");
        sb.AppendLine();

        // Add columns
        AppendColumnDefinitions(sb, metadata);
        sb.AppendLine();

        // Add rows
        AppendRowPopulation(sb, metadata);

        sb.AppendLine();
        sb.AppendLine("        return dataTable;");
        sb.AppendLine("    }");
    }

	/// <summary>
	///     Constructs the fully qualified TVP name in the format [Schema].[TvpName].
	/// </summary>
	/// <param name="metadata">The metadata containing TVP schema and name.</param>
	/// <returns>The fully qualified TVP name.</returns>
	/// <exception cref="InvalidOperationException">Thrown if TvpName is null or empty.</exception>
	/// <remarks>
	///     The schema defaults to "dbo" if not specified in the metadata.
	/// </remarks>
	private static string GetTvpName(Metadata metadata)
    {
        var schema = metadata.TvpSchema ?? "dbo";
        var tvpName = metadata.TvpName ?? throw new InvalidOperationException("TvpName is required");

        return $"{schema}.{tvpName}";
    }

	/// <summary>
	///     Appends DataTable column definitions matching the TVP schema.
	/// </summary>
	/// <param name="sb">The <see cref="StringBuilder" /> to append to.</param>
	/// <param name="metadata">The metadata containing parameter information.</param>
	/// <remarks>
	///     Each parameter becomes a column in the DataTable, with the column type
	///     set to the underlying non-nullable .NET type (DataTable handles nullability separately).
	/// </remarks>
	private static void AppendColumnDefinitions(StringBuilder sb, Metadata metadata)
    {
        sb.AppendLine("        // Add columns");
        foreach (var parameter in metadata.Parameters)
        {
            var dotNetType = GetDotNetTypeForDataTable(parameter);
            sb.AppendLine($"        dataTable.Columns.Add(\"{parameter.Name}\", typeof({dotNetType}));");
        }
    }

	/// <summary>
	///     Appends the row population logic that fills the DataTable with data from the input collection.
	/// </summary>
	/// <param name="sb">The <see cref="StringBuilder" /> to append to.</param>
	/// <param name="metadata">The metadata containing parameter information.</param>
	/// <remarks>
	///     Generates a foreach loop that creates DataTable rows from the input items,
	///     mapping each property to its corresponding column.
	/// </remarks>
	private static void AppendRowPopulation(StringBuilder sb, Metadata metadata)
    {
        sb.AppendLine("        // Populate rows");
        sb.AppendLine("        foreach (var item in items)");
        sb.AppendLine("        {");

        var valuesString = string.Join(", ", metadata.Parameters.Select(static p => $"item.{p.Name}"));
        sb.AppendLine($"            dataTable.Rows.Add({valuesString});");

        sb.AppendLine("        }");
    }

	/// <summary>
	///     Extracts the underlying non-nullable .NET type for DataTable column definition.
	/// </summary>
	/// <param name="parameter">The parameter metadata containing type information.</param>
	/// <returns>The non-nullable type name suitable for typeof() expression in generated code.</returns>
	/// <remarks>
	///     <para>
	///         DataTable columns require non-nullable types; nullability is handled through DBNull.Value.
	///         This method strips nullable annotations (?) and Nullable&lt;T&gt; wrappers.
	///     </para>
	///     <para>
	///         Type aliases (int, string, etc.) are preserved for readability in generated code.
	///     </para>
	/// </remarks>
	private static string GetDotNetTypeForDataTable(ParameterMetadata parameter)
    {
        var typeName = parameter.TypeName.AsSpan();

        // Remove nullable annotation if present (e.g., "int?" -> "int")
        if (typeName.Length > 0 && typeName[typeName.Length - 1] == '?')
            typeName = typeName.Slice(0, typeName.Length - 1);

        // Handle Nullable<T> syntax (e.g., "System.Nullable<int>" -> "int")
        const string nullablePrefix = "System.Nullable<";
        if (typeName.Length > nullablePrefix.Length + 1 &&
            typeName.StartsWith(nullablePrefix.AsSpan()) &&
            typeName[typeName.Length - 1] == '>')
            typeName = typeName.Slice(nullablePrefix.Length, typeName.Length - nullablePrefix.Length - 1);

        // Convert span back to string for the switch expression
        var typeString = typeName.ToString();

        // Map type aliases (keeping them as-is for readability) and return
        return typeString switch
        {
            _ => typeString
        };
    }

	/// <summary>
	///     Appends the closing brace for the type declaration.
	/// </summary>
	/// <param name="sb">The <see cref="StringBuilder" /> to append to.</param>
	private static void AppendClassEnd(StringBuilder sb)
    {
        sb.AppendLine("}");
    }

	/// <summary>
	///     Placeholder for namespace closing (not needed with file-scoped namespaces).
	/// </summary>
	/// <param name="sb">The <see cref="StringBuilder" /> (unused).</param>
	/// <param name="namespaceName">The namespace name (unused).</param>
	/// <remarks>
	///     With C# 10+ file-scoped namespaces, no closing brace is required.
	///     This method exists for symmetry and potential future use.
	/// </remarks>
	private static void AppendNamespaceEnd(StringBuilder sb, string namespaceName)
    {
        // File-scoped namespaces don't require closing
    }
}