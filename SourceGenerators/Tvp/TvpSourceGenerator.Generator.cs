namespace CaeriusNet.Generator.Tvp;

public sealed partial class TvpSourceGenerator
{
	/// <summary>
	///     Generates and adds the <see cref="ITvpMapper{T}" /> implementation source code to the compilation.
	/// </summary>
	/// <param name="context">The source production context for adding generated source files.</param>
	/// <param name="metadata">The metadata containing type and TVP configuration information.</param>
	/// <remarks>
	///     This method orchestrates the complete code generation process for a single TVP mapper,
	///     producing a file named "{TypeName}.g.cs" containing the implementation.
	/// </remarks>
	private static void GenerateTvpMapper(SourceProductionContext context, Metadata metadata)
	{
		string sourceCode = GenerateTvpMapperSource(metadata);
		string fileName = $"{metadata.RecordName}.g.cs";

		context.AddSource(fileName, sourceCode);
	}

	/// <summary>
	///     Generates the complete source code for an <see cref="ITvpMapper{T}" /> implementation.
	/// </summary>
	/// <param name="metadata">The metadata containing all necessary information for code generation.</param>
	/// <returns>A string containing the complete C# source code for the TVP mapper.</returns>
	/// <remarks>
	///     <para>
	///         The generated code includes:
	///     </para>
	///     <list type="bullet">
	///         <item>
	///             <description>Auto-generated file header with nullable enable directive</description>
	///         </item>
	///         <item>
	///             <description>Required using statements</description>
	///         </item>
	///         <item>
	///             <description>File-scoped namespace declaration</description>
	///         </item>
	///         <item>
	///             <description>Partial class/record implementing ITvpMapper</description>
	///         </item>
	///         <item>
	///             <description>MapAsDataTable method that creates and populates a DataTable</description>
	///         </item>
	///     </list>
	/// </remarks>
	private static string GenerateTvpMapperSource(Metadata metadata)
	{
		// Estimate capacity: ~500 base + ~100 per parameter
		int estimatedCapacity = 500 + metadata.Parameters.Count * 100;
		var sb = new StringBuilder(estimatedCapacity);

		// File header and usings
		AppendFileHeader(sb);
		AppendUsings(sb);

		// Namespace and class declaration
		AppendNamespaceStart(sb, metadata.Namespace);
		AppendClassDeclaration(sb, metadata);

		// Generate the MapAsDataTable method
		AppendMapAsDataTableMethod(sb, metadata);

		// Close class and namespace
		AppendClassEnd(sb);
		AppendNamespaceEnd(sb, metadata.Namespace);

		return sb.ToString();
	}

	/// <summary>
	///     Appends the standard auto-generated file header.
	/// </summary>
	/// <param name="sb">The <see cref="StringBuilder" /> to append to.</param>
	/// <remarks>
	///     Includes an auto-generated comment and enables nullable reference types for the file.
	/// </remarks>
	private static void AppendFileHeader(StringBuilder sb)
	{
		sb.AppendLine("// <auto-generated/>");
		sb.AppendLine("#nullable enable");
		sb.AppendLine();
	}

	/// <summary>
	///     Appends the required using directives for the generated TVP mapper.
	/// </summary>
	/// <param name="sb">The <see cref="StringBuilder" /> to append to.</param>
	/// <remarks>
	///     Includes namespaces for:
	///     <list type="bullet">
	///         <item>
	///             <description><see cref="System" /> - Core types</description>
	///         </item>
	///         <item>
	///             <description><see cref="System.Collections.Generic" /> - Generic collections</description>
	///         </item>
	///         <item>
	///             <description><see cref="System.Data" /> - DataTable and related ADO.NET types</description>
	///         </item>
	///         <item>
	///             <description>CaeriusNet.Mappers - ITvpMapper interface</description>
	///         </item>
	///     </list>
	/// </remarks>
	private static void AppendUsings(StringBuilder sb)
	{
		sb.AppendLine("using System;");
		sb.AppendLine("using System.Collections.Generic;");
		sb.AppendLine("using System.Data;");
		sb.AppendLine("using CaeriusNet.Mappers;");
		sb.AppendLine();
	}

	/// <summary>
	///     Appends a file-scoped namespace declaration.
	/// </summary>
	/// <param name="sb">The <see cref="StringBuilder" /> to append to.</param>
	/// <param name="namespaceName">The namespace name, or empty/null for global namespace.</param>
	/// <remarks>
	///     Uses C# 10+ file-scoped namespace syntax. If the namespace is empty or null, no declaration is added.
	/// </remarks>
	private static void AppendNamespaceStart(StringBuilder sb, string namespaceName)
	{
		if (string.IsNullOrEmpty(namespaceName))
			return;

		sb.AppendLine($"namespace {namespaceName};");
		sb.AppendLine();
	}

	/// <summary>
	///     Appends the partial type declaration implementing <see cref="ITvpMapper{T}" />.
	/// </summary>
	/// <param name="sb">The <see cref="StringBuilder" /> to append to.</param>
	/// <param name="metadata">The metadata containing type information.</param>
	/// <remarks>
	///     Generates a sealed partial record with the ITvpMapper interface and includes
	///     a static TvpTypeName property containing the fully qualified TVP name ([Schema].[TvpName]).
	/// </remarks>
	private static void AppendClassDeclaration(StringBuilder sb, Metadata metadata)
	{
		sb.AppendLine($"public sealed partial record {metadata.RecordName} : ITvpMapper<{metadata.RecordName}>");
		sb.AppendLine("{");

		// Add static property for TVP type name
		string tvpName = GetTvpName(metadata);
		sb.AppendLine("    /// <summary>");
		sb.AppendLine("    ///     Gets the SQL Server type name for this TVP.");
		sb.AppendLine("    /// </summary>");
		sb.AppendLine($"    public static string TvpTypeName => \"{tvpName}\";");
		sb.AppendLine();
	}

	/// <summary>
	///     Appends the MapAsDataTable method implementation.
	/// </summary>
	/// <param name="sb">The <see cref="StringBuilder" /> to append to.</param>
	/// <param name="metadata">The metadata containing parameter and TVP information.</param>
	/// <remarks>
	///     <para>
	///         Generates the MapAsDataTable method which converts a collection of objects into a properly structured
	///         <see cref="DataTable" /> for use as a SQL Server Table-Valued Parameter.
	///     </para>
	///     <para>
	///         The method:
	///     </para>
	///     <list type="number">
	///         <item>
	///             <description>Creates a new DataTable with the TVP name</description>
	///         </item>
	///         <item>
	///             <description>Defines columns matching the TVP schema</description>
	///         </item>
	///         <item>
	///             <description>Populates rows from the input collection</description>
	///         </item>
	///     </list>
	/// </remarks>
	private static void AppendMapAsDataTableMethod(StringBuilder sb, Metadata metadata)
	{
		string tvpName = GetTvpName(metadata);

		sb.AppendLine("    /// <summary>");
		sb.AppendLine($"    ///     Maps a collection of {metadata.RecordName} objects to a DataTable for TVP usage.");
		sb.AppendLine("    /// </summary>");
		sb.AppendLine($"    public DataTable MapAsDataTable(IEnumerable<{metadata.RecordName}> items)");
		sb.AppendLine("    {");
		sb.AppendLine($"        var dataTable = new DataTable(\"{tvpName}\");");
		sb.AppendLine();

		// Add columns
		AppendColumnDefinitions(sb, metadata);
		sb.AppendLine();

		// Add rows
		AppendRowPopulation(sb, metadata);

		sb.AppendLine();
		sb.AppendLine("        return dataTable;");
		sb.AppendLine("    }");
	}

	/// <summary>
	///     Constructs the fully qualified TVP name in the format [Schema].[TvpName].
	/// </summary>
	/// <param name="metadata">The metadata containing TVP schema and name.</param>
	/// <returns>The fully qualified TVP name.</returns>
	/// <exception cref="InvalidOperationException">Thrown if TvpName is null or empty.</exception>
	/// <remarks>
	///     The schema defaults to "dbo" if not specified in the metadata.
	/// </remarks>
	private static string GetTvpName(Metadata metadata)
	{
		string schema = metadata.TvpSchema ?? "dbo";
		string tvpName = metadata.TvpName ?? throw new InvalidOperationException("TvpName is required");

		return $"{schema}.{tvpName}";
	}

	/// <summary>
	///     Appends DataTable column definitions matching the TVP schema.
	/// </summary>
	/// <param name="sb">The <see cref="StringBuilder" /> to append to.</param>
	/// <param name="metadata">The metadata containing parameter information.</param>
	/// <remarks>
	///     Each parameter becomes a column in the DataTable, with the column type
	///     set to the underlying non-nullable .NET type (DataTable handles nullability separately).
	/// </remarks>
	private static void AppendColumnDefinitions(StringBuilder sb, Metadata metadata)
	{
		sb.AppendLine("        // Add columns");
		foreach (var parameter in metadata.Parameters){
			string dotNetType = GetDotNetTypeForDataTable(parameter);
			sb.AppendLine($"        dataTable.Columns.Add(\"{parameter.Name}\", typeof({dotNetType}));");
		}
	}

	/// <summary>
	///     Appends the row population logic that fills the DataTable with data from the input collection.
	/// </summary>
	/// <param name="sb">The <see cref="StringBuilder" /> to append to.</param>
	/// <param name="metadata">The metadata containing parameter information.</param>
	/// <remarks>
	///     Generates a foreach loop that creates DataTable rows from the input items,
	///     mapping each property to its corresponding column.
	/// </remarks>
	private static void AppendRowPopulation(StringBuilder sb, Metadata metadata)
	{
		sb.AppendLine("        // Populate rows");
		sb.AppendLine("        foreach (var item in items)");
		sb.AppendLine("        {");

		string valuesString = string.Join(", ", metadata.Parameters.Select(static p => $"item.{p.Name}"));
		sb.AppendLine($"            dataTable.Rows.Add({valuesString});");

		sb.AppendLine("        }");
	}

	/// <summary>
	///     Extracts the underlying non-nullable .NET type for DataTable column definition.
	/// </summary>
	/// <param name="parameter">The parameter metadata containing type information.</param>
	/// <returns>The non-nullable type name suitable for typeof() expression in generated code.</returns>
	/// <remarks>
	///     <para>
	///         DataTable columns require non-nullable types; nullability is handled through DBNull.Value.
	///         This method strips nullable annotations (?) and Nullable&lt;T&gt; wrappers.
	///     </para>
	///     <para>
	///         Type aliases (int, string, etc.) are preserved for readability in generated code.
	///     </para>
	/// </remarks>
	private static string GetDotNetTypeForDataTable(ParameterMetadata parameter)
	{
		var typeName = parameter.TypeName.AsSpan();

		// Remove nullable annotation if present (e.g., "int?" -> "int")
		if (typeName.Length > 0 && typeName[typeName.Length - 1] == '?')
			typeName = typeName[..^1];

		// Handle Nullable<T> syntax (e.g., "System.Nullable<int>" -> "int")
		const string nullablePrefix = "System.Nullable<";
		if (typeName.Length > nullablePrefix.Length + 1 &&
		    typeName.StartsWith(nullablePrefix.AsSpan()) &&
		    typeName[typeName.Length - 1] == '>')
			typeName = typeName.Slice(nullablePrefix.Length, typeName.Length - nullablePrefix.Length - 1);

		// Convert span back to string for the switch expression
		string typeString = typeName.ToString();

		// Map type aliases (keeping them as-is for readability) and return
		return typeString switch
		{
			_ => typeString
		};
	}

	/// <summary>
	///     Appends the closing brace for the type declaration.
	/// </summary>
	/// <param name="sb">The <see cref="StringBuilder" /> to append to.</param>
	private static void AppendClassEnd(StringBuilder sb)
	{
		sb.AppendLine("}");
	}

	/// <summary>
	///     Placeholder for namespace closing (not needed with file-scoped namespaces).
	/// </summary>
	/// <param name="sb">The <see cref="StringBuilder" /> (unused).</param>
	/// <param name="namespaceName">The namespace name (unused).</param>
	/// <remarks>
	///     With C# 10+ file-scoped namespaces, no closing brace is required.
	///     This method exists for symmetry and potential future use.
	/// </remarks>
	private static void AppendNamespaceEnd(StringBuilder sb, string namespaceName)
	{
		// File-scoped namespaces don't require closing
	}
}